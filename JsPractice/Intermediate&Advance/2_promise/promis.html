<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <div>
        <p>
            A Promise is an object representing the eventual completion or failure of an asynchronous operation. Since
            most people are consumers of already-created promises,
            this guide will explain consumption of returned promises before explaining how to create them.

            Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into
            a function. Imagine a function,
            createAudioFileAsync(), which asynchronously generates a sound file given a configuration record and two
            callback functions: one called if the audio file is successfully created,
            and the other called if an error occurs.

            Here's some code that uses createAudioFileAsync():
            <samp style="display: block;">
                function successCallback(result) {  <br>
                console.log(`Audio file ready at URL: ${result}`);<br>
                }

                function failureCallback(error) {<br>
                console.error(`Error generating audio file: ${error}`);<br>
                }

                createAudioFileAsync(audioSettings, successCallback, failureCallback); <br> <br>

                If createAudioFileAsync() were rewritten to return a promise, you would attach your callbacks to it
                instead:

                js
                Copy to Clipboard
                createAudioFileAsync(audioSettings).then(successCallback, failureCallback);
                This convention has several advantages. We will explore each one.

            </samp>
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN Documentation</a>
        </p>
        <p>
        <h5>Chaining </h5>
        A common need is to execute two or more asynchronous operations back to back, where each subsequent operation
        starts when the previous operation succeeds,
        with the result from the previous step. In the old days, doing several asynchronous operations in a row would
        lead to the classic callback hell
        <samp style="display: block;">
            doSomething(function (result) {<br>
                doSomethingElse(result, function (newResult) { <br>
                  doThirdThing(newResult, function (finalResult) { <br>
                    console.log(`Got the final result: ${finalResult}`); <br>
                  }, failureCallback); <br>
                }, failureCallback); <br>
              }, failureCallback); <br>
              
        </samp>
        </p>
        <p>
            <h5>Fetch API Documentation</h5>
            <a href="https://blog.logrocket.com/fetch-api-node-js/">click here for Documentation </a> <br>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch">MDN Documentation</a>
        </p>
    </div>
</body>

</html>